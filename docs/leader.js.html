<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: leader.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: leader.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable */

import { Observable } from 'rxjs';
import { CreateMode } from 'node-zookeeper-client';
import uuid from 'uuid/v4';
import pify from 'pify';

import { observeNodeChildren } from './util';
import { getClientNodePrefix, sortBySequence } from './client';

/**
* Attempts to acquire a lock and the given path and observes the lock state
* @param {Object} options - The options
* @param {Observable} options.clientState$ - The client state observable
* @param {string} options.path - The path at which to observe
* @param {function} options.watchSelector - Function that is called back with
* @param {string} [options.clientId] - The client id to use, one is allocated if not supplied
*/
export function observeLeaderState(options) {
  const { clientState$, path, watchSelector, clientId = null } = options;

  // construct the client node prefix that will represent this client in
  // this leader process ...
  const clientNodePrefix = getClientNodePrefix(clientId || uuid());

  /*
  // when the client is in the connected state, the leader state is
  // determined by doing the following in a loop against a node designated
  // for this leader election:
  // 1) read the children
  // 2) see where the node for this participant is, in the list.
  // 3) based on ABC
  // kgw -- first time optimization?
  const observeConnectedLeaderState = client => null;
    observeNodeChildren({ client, path, sort: sortBySequence }).flatMap((clientNodes) => {
      const clientIndex = clientNodes.findIndex(node => node.startsWith(clientNodePrefix));
      if (clientIndex >= 0) {
        // we found our node here ...
        const isLeader = clientIndex === 0;
        const clientNode = clientNodes[clientIndex];
        const clientPath = [path, clientNode].join('/');

        // determine the path to watc
        const watchPath = isLeader ?
          clientPath :
          [path, clientNodes[watchSelector(clientNodes, clientIndex)]].join('/');



      }

      // this means that our node isn't even present, so create the node
      // so that, next time around, we'll expect to see our node
      // in the list and can proceed with the protocol.
      return pify(client.create).call(
        client,
        [path, clientNodePrefix].join('/'),
        null,
        CreateMode.EPHEMERAL_SEQUENTIAL
      );

    })); //s.retryWhen(completion$ => completion$.map(() => true));

  // map from the client states to the leader states. if disconnected,
  // the the leader state is always false and that's all we know
  return clientState$.flatMap(({ client, connected }) => connected ?
    observeConnectedLeaderState(client) :
    Observable.of({ isLeader: false });
  );
  */

}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#changeEventName">changeEventName</a></li><li><a href="global.html#connect">connect</a></li><li><a href="global.html#generateClientId">generateClientId</a></li><li><a href="global.html#getClientNodePrefix">getClientNodePrefix</a></li><li><a href="global.html#getExclusiveLock">getExclusiveLock</a></li><li><a href="global.html#leaderSelector">leaderSelector</a></li><li><a href="global.html#makeRetryable">makeRetryable</a></li><li><a href="global.html#observeClientState">observeClientState</a></li><li><a href="global.html#observeConnectedState">observeConnectedState</a></li><li><a href="global.html#observeCreateNode">observeCreateNode</a></li><li><a href="global.html#observeDelay">observeDelay</a></li><li><a href="global.html#observeExclusiveLock">observeExclusiveLock</a></li><li><a href="global.html#observeLeaderState">observeLeaderState</a></li><li><a href="global.html#observeNodeChildren">observeNodeChildren</a></li><li><a href="global.html#observeNodeValue">observeNodeValue</a></li><li><a href="global.html#observeOneForAllAction">observeOneForAllAction</a></li><li><a href="global.html#observeRemoveNode">observeRemoveNode</a></li><li><a href="global.html#observeSeekClientNodeState">observeSeekClientNodeState</a></li><li><a href="global.html#observeSeekState">observeSeekState</a></li><li><a href="global.html#parseClientNode">parseClientNode</a></li><li><a href="global.html#sortClientNodesBySequence">sortClientNodesBySequence</a></li><li><a href="global.html#unsubscribe">unsubscribe</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Apr 03 2017 10:39:39 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
